type Query @guard(with: ["web", "api"]) {
    me: User @auth
}

type Mutation @guard(with: ["web", "api"]) {
    updateMe(input: UpdateUserInput!): UserMutationResponse @field(resolver: "UserQuery@update") @broadcast(subscription: "meUpdated")
}

type Subscription {
    meUpdated: UserMutationResponse @subscription(class: "MeUpdated")
    nodeCreated: NodeMutationResponse @subscription(class: "NodeSubscription")
    nodeUpdated: NodeMutationResponse @subscription(class: "NodeSubscription")
    nodeDeleted: NodeMutationResponse @subscription(class: "NodeSubscription")
    nodeRestored: NodeMutationResponse @subscription(class: "NodeSubscription")

    progressTrackerUpdated(taskId: ID!): ProgressTracker @subscription(class: "ProgressTrackerUpdatedSubscription")
}

type ProgressTracker {
    id: ID!
    status: TaskStatus!
    processedCount: Int
    totalCount: Int
    progress: Float
    message: String
    estimatedTimeRemaining: Int
    startedAt: DateTime
    finishedAt: DateTime
    cancelledAt: DateTime
    revertedAt: DateTime
    revertFinishedAt: DateTime
}

interface MutationResponse {
    code: String!
    success: Boolean!
    message: String!
}

type NodeMutationResponse implements MutationResponse {
    code: String!
    success: Boolean!
    message: String!
    event: String!
    node: Node
}

type SuccessfulMutationResponse {
    code: String!
    success: Boolean!
    message: String!
}

type OptionalLengthPaginatorInfo {
    count: Int!
    currentPage: Int!
    firstItem: Int
    lastItem: Int
    perPage: Int!
    hasMorePages: Boolean!
    total: Int
}

# This can be registered by the relation directive, but we only ever use it
# manually with the integrations, so we need to register it manually.
"Information about pagination using a simple paginator."
type SimplePaginatorInfo {
    "Number of items in the current page."
    count: Int!

    "Index of the current page."
    currentPage: Int!

    "Index of the first item in the current page."
    firstItem: Int

    "Index of the last item in the current page."
    lastItem: Int

    "Number of items per page."
    perPage: Int!

    "Are there more pages after this one?"
    hasMorePages: Boolean!
}

"Information about pagination using a Relay style cursor connection."
type PageInfo {
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!

    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!

    "The cursor to continue paginating backwards."
    startCursor: String

    "The cursor to continue paginating forwards."
    endCursor: String

    "Total number of nodes in the paginated connection."
    total: Int

    "Total number of nodes without any filters."
    rawTotal: Int

    "Number of nodes in the current page."
    count: Int!

    "Index of the current page."
    currentPage: Int!

    "Index of the last available page."
    lastPage: Int!
}

#import scalars.graphql
#import history.graphql
#import locations.graphql
#import manager/manager.graphql
#import mappings/mappings.graphql
#import account/account.graphql
